<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

<#
string[] prefixes = {"Instream","Storage"};
string[] parent = {"ProxyLinkSourceSinkModel","ProxyStorageSourceSinkModel"};
string[][] parentParameters=new[]{
	new[]{"bool IsFloodplain"},
	new[]{"double FloodplainElevation"}
};
bool[] clone = {true,false};
string[] flags = {"IsFloodplain"};
string[] parameters = {"MaxAccumulationArea squareMetres","LeafAccumulationConstant",
					   "ReaerationCoefficient","DocConsumptionCoefficient","LeafA","LeafK1","LeafK2",
					   "InitialLeafDryMatterReadilyDegradable","InitialLeafDryMatterNonReadilyDegradable",
					   "PrimaryProductionReaeration","TemperatureObs"};
string[] arrayParams = {"tempX","DOC_max","DOC_k","ProductionCoefficients","ProductionBreaks"};
string[] outputs = {"ZoneCount double","CountInundatedZones int","CountDryZones int","LeafDryMatterReadilyDegradable double","LeafDryMatterNonReadilyDegradable double",
			        "TemperatureEst double","SoilO2Kg double","DoCo2 double","Production double","Reaeration double",
					"ConsumedDocMilligrams double","DOCEnteringWater double","TotalWetLeaf double",
					"LeafWetMatterReadilyDegradable double","LeafWetMatterNonReadilyDegradable double",
					"FloodplainWetAreaHa double", "FloodplainDryAreaHa double",
					"Leach1 double", "LeachingRate double", "DocMax double"};#>

using RiverSystem;
using TIME.Core.Metadata;
using TIME.Core;
using RiverSystem.Api.NetworkElements.Common.Constituents;

<# for(int i=0; i<prefixes.Length; i++)
   {
 #>
namespace FlowMatters.Source.DODOC.<#= prefixes[i] #>
{
	[WorksWith(typeof(<#= prefixes[i] #>DO))]
	public class <#= prefixes[i] #>DOAPI : ProcessingModel<<#= prefixes[i] #>DO >{
		public new string Name
		{
			get
			{
				return "<#= prefixes[i] #> DO";
			}
		}

<#
foreach(var pp in parentParameters[i]) {
		  var ptype = pp.Split(' ')[0];
		  var pname = pp.Split(' ')[1];#>
		public <#= pp #>
		{
			get{ return Feature.<#=pname#>; }
			set{ Feature.<#=pname#> = value; }
		}
<#
} #>
	}

    public class <#= prefixes[i] #>DO : <#= parent[i] #>
    {
        public <#= prefixes[i] #>DO()
        {
        }

<#
if(clone[i]){ #>
			public override LinkSourceSinkModel CloneForMultipleDivisions()
			{
				return new <#= prefixes[i] #>DO() { 
<#
foreach(var flag in flags) { #>
					<#= flag #> = <#= flag#>,
				};
<#
} #>
			}
		
<#
} #>

        protected override void UpdateWorker(double constituentConcentration)
        {
            Worker.ConcentrationDo = constituentConcentration;
        }

        protected override void RetrieveResults()
        {
            ProcessedLoad = Worker.DissolvedOxygenLoad;
        }
    }

	[WorksWith(typeof(<#= prefixes[i] #>DOC))]
	public class <#= prefixes[i] #>DOCAPI : ProcessingModel<<#= prefixes[i] #>DOC >{
		public new string Name
		{
			get
			{
				return "<#= prefixes[i] #> DOC";
			}
		}

<#
foreach(var pp in parentParameters[i]) {
		  var ptype = pp.Split(' ')[0];
		  var pname = pp.Split(' ')[1];#>
		public <#= pp #>
		{
			get{ return Feature.<#=pname#>; }
			set{ Feature.<#=pname#> = value; }
		}
<#
} #>

<#
foreach(var param in parameters){ 
		var bits = param.Split(' ');
		var p = bits[0];#>
		[Parameter<# if(bits.Length>1){#>,CalculationUnits(CommonUnits.<#=bits[1]#>)<#}#>]
		public double <#= p #> {
			get{ return Feature.<#= p #>;} 
			set{ Feature.<#= p #> = value;}
		}
<#
} #>

<#
foreach(var param in arrayParams){ #>
		[Parameter]
		public double[] <#= param #> {
			get{ return Feature.<#= param #>;} 
			set{ Feature.<#= param #> = value;}
		}
<#
} #>


	}


    public class <#= prefixes[i] #>DOC : <#= parent[i] #>
    {
        public <#= prefixes[i] #>DOC()
        {
        }

        // WHEN ADDING PROPERTIES, REMEMBER TO CLONE!
<#
foreach(var param in parameters){ 
		var bits = param.Split(' ');
		var p = bits[0];#>
		[Parameter<# if(bits.Length>1){#>,CalculationUnits(CommonUnits.<#=bits[1]#>)<#}#>] public double <#= p #> {get; set;}
<#
} #>

<#
foreach(var param in arrayParams){ #>
		[Parameter] public double[] <#= param #> {get; set;}
<#
} #>
		
<#
foreach(var output in outputs){ 
			var nm = output.Split(' ')[0];
			var dt = output.Split(' ')[1];#>
		[Output] public <#= dt #> <#= nm #> {get; private set;}

<#
} #>

<#
if(clone[i]){ #>
		public override LinkSourceSinkModel CloneForMultipleDivisions()
		{
			return new <#= prefixes[i] #>DOC() { 
<#
foreach(var flag in flags) { #>
				<#= flag #> = <#= flag#>,
<#
} #>
<#
foreach(var param in parameters) {
						var p = param.Split(' ')[0];
						#>
 
				<#= p#> = <#= p#>,
<#
} #>
<#
foreach(var param in arrayParams) { #>
				<#= param #> = (double[])((<#= param #>==null)?null:<#= param #>.Clone()),
<#
} #>
			};
		}
		
<#
} #>

        protected override void UpdateWorker(double constituentConcentration)
        {
            Worker.ConcentrationDoc = constituentConcentration;

<#
foreach( var param in parameters){
					var p = param.Split(' ')[0];
 #>
			Worker.<#=p#> = <#=p#>;
<#
} #>

<#
foreach( var param in arrayParams){ #>
			  if(<#=param#>==null){
			<#=param#> = Worker.<#=param#>;
			  } else {
			Worker.<#=param#> = <#=param#>;
			  }
<#
} #>

<#
if(clone[i]){ #>
			Worker.Fac = 1.0/(this.Link.Divisions.Count);
<#
} else { #>
			Worker.Fac = 1.0;
<#
} #>
        }

        protected override void RetrieveResults()
        {
            ProcessedLoad = Worker.DissolvedOrganicCarbonLoad;
<#
foreach(var output in outputs) {
			 var nm = output.Split(' ')[0];#>
			<#=nm#> = Worker.<#=nm#>;
<#
} #>
        }
    }

}

<# } #>


