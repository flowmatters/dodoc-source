<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

<#
string[] prefixes = {"Instream","Storage"};
string[] parent = {"ProxyLinkSourceSinkModel","ProxyStorageSourceSinkModel"};
bool[] clone = {true,false};
string[] flags = {"IsFloodplain"};
string[] parameters = {"DecompositionCoefficient","MaxAccumulationArea squareMetres","Fac","LeafAccumulationConstant",
					   "ReaerationCoefficient","DocConsumptionCoefficient","LeafA","LeafK1","LeafK2",
					   "InitialLeafDryMatterReadilyDegradable","InitialLeafDryMatterNonReadilyDegradable",
					   "SoilO2Scaling","PrimaryProductionReaeration","TemperatureObs"};
string[] arrayParams = {"tempX","DOC_max","DOC_k","ProductionCoefficients","ProductionBreaks"};
string[] outputs = {"ZoneCount double","CountInundatedZones int","CountDryZones int","LeafDryMatterReadilyDegradable double","LeafDryMatterNonReadilyDegradable double",
			        "TemperatureEst double","SoilO2Kg double","DoCo2 double","Production double","Reaeration double",
					"ConsumedDocMilligrams double","DOCEnteringWater double","TotalWetLeaf double",
					"LeafWetMatterReadilyDegradable double","LeafWetMatterNonReadilyDegradable double",
					"FloodplainWetAreaHa double", "FloodplainDryAreaHa double",
					"Leach1 double", "LeachingRate double", "DocMax double"};#>

using RiverSystem;
using TIME.Core.Metadata;
using TIME.Core;

<# for(int i=0; i<prefixes.Length; i++)
   {
 #>
namespace FlowMatters.Source.DODOC.<#= prefixes[i] #>
{
    public class <#= prefixes[i] #>DO : <#= parent[i] #>
    {
        public <#= prefixes[i] #>DO()
        {
        }

		<# if(clone[i]){ #>
			public override LinkSourceSinkModel CloneForMultipleDivisions()
			{
				return new <#= prefixes[i] #>DO() { 
				<# foreach(var flag in flags) { #>
					<#= flag #> = <#= flag#>,
				};
				<# } #>
			}
		
		<# } #>

        protected override void UpdateWorker(double constituentConcentration)
        {
            Worker.ConcentrationDo = constituentConcentration;
        }

        protected override void RetrieveResults()
        {
            ProcessedLoad = Worker.DissolvedOxygenLoad;
        }
    }

    public class <#= prefixes[i] #>DOC : <#= parent[i] #>
    {
        public <#= prefixes[i] #>DOC()
        {
        }

        // WHEN ADDING PROPERTIES, REMEMBER TO CLONE!
		<# foreach(var param in parameters){ 
		var bits = param.Split(' ');
		var p = bits[0];#>
[Parameter<# if(bits.Length>1){#>,CalculationUnits(CommonUnits.<#=bits[1]#>)<#}#>] public double <#= p #> {get; set;}
		<# } #>

		<# foreach(var param in arrayParams){ #>
[Parameter] public double[] <#= param #> {get; set;}
		<# } #>
		
		<# foreach(var output in outputs){ 
			var nm = output.Split(' ')[0];
			var dt = output.Split(' ')[1];#>
[Output] public <#= dt #> <#= nm #> {get; private set;}

		<# } #>

		<# if(clone[i]){ #>
public override LinkSourceSinkModel CloneForMultipleDivisions()
{
	return new <#= prefixes[i] #>DOC() { 
				<# foreach(var flag in flags) { #>
	<#= flag #> = <#= flag#>,
				<# } #>
				<# foreach(var param in parameters) {
						var p = param.Split(' ')[0];
						#>
 
	<#= p#> = <#= p#>,
				<# } #>
				<# foreach(var param in arrayParams) { #>
	<#= param #> = (double[])((<#= param #>==null)?null:<#= param #>.Clone()),
				<# } #>
	};
	}
		
		<# } #>

        protected override void UpdateWorker(double constituentConcentration)
        {
            Worker.ConcentrationDoc = constituentConcentration;

			<# foreach( var param in parameters){
					var p = param.Split(' ')[0];
 #>
			Worker.<#=p#> = <#=p#>;
			<# } #>

			<# foreach( var param in arrayParams){ #>
			  if(<#=param#>==null){
			<#=param#> = Worker.<#=param#>;
			  } else {
			Worker.<#=param#> = <#=param#>;
			  }
			<# } #>

			<# if(clone[i]){ #>
			Worker.Fac = 1.0/(this.Link.Divisions.Count);
			<# } else { #>
			Worker.Fac = 1.0;
			<# } #>
        }

        protected override void RetrieveResults()
        {
            ProcessedLoad = Worker.DissolvedOrganicCarbonLoad;
			<# foreach(var output in outputs) {
			 var nm = output.Split(' ')[0];#>
			<#=nm#> = Worker.<#=nm#>;
			<# } #>
        }
    }

}

<# } #>


